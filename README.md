[Memorious 바로가기](https://naver.com/)

<div align="center">

# Memorious - 우리 가족만을 위한 플랫폼
  <img src="https://github.com/KoreaIt-J-23-2-5/Memorious-Front/assets/133538833/0b8a28b9-7d2f-4732-90d8-ebcd9e0de5da" width="40%">

  #### 코리아IT아카데미(부산) 
  #### AWS 기반 공공ㆍ빅데이터 활용 웹서비스 개발자 양성과정(2회차)
  #### 최종 프로젝트 : 4조
</div>


## 목차
- [프로젝트 소개](프로젝트-소개)
- [팀 소개](팀-소개)
- [개발환경](개발-환경)
- [협업 방식](협업-방식)
- [컨벤션](컨벤션)
- [주요기능 설명](주요-기능-설명)
- [각종 문서](문서)
- [화면 구현 및 코드리뷰](화면-구현-및-코드리뷰)
- [문제 해결](문제-해결)
- [회고](느낀-점)

  
## 프로젝트 소개
#### 프로젝트 개요
- MemorioUs는 '왜 가족만을 위한 플랫폼은 없을까?' 라는 물음과 함께 시작된 프로젝트입니다.
- 'memory'와 'us'의 합성어로, 단어 그대로의 뜻과 함께 '특별히 기억할만한 우리의 추억'을 의미합니다.
- MemorioUs에서는 멀리 떨어져 있는 가족들도 손쉽게 의사소통하고 추억을 기록 할 수 있도록 다양한 기능을 지원합니다.
  - 캘린더 : 개인 및 가족 일정을 하나의 달력에 담아 시각적으료 보여주어 효과적인 일정 관리를 돕습니다.
  - 메모 : 가족 간 간단한 메시지나 메모를 공유해 편리한 의사소통을 돕습니다.
  - 게시판 : 다양한 주제로 게시글을 작성하고 공유함으로써 공지사항, 회의, 건의사항, 일상, 여행 등을 효과적으로 기록할 수 있습니다.
  - 건강 차트 : 본인의 일일 걸음수/혈당/맥박을 기록하고 가족의 데이터를 그래프로 확인하여 건강을 관리할 수 있습니다.
- 간편한 카카오/네이버 소셜 로그인을 지원하며, 가족에게 초대 메일을 보내 손쉽게 가족 구성원을 초대할 수 있습니다.


#### 개발 기간
  - 2023.11.03 ~ 2023.11.29 (27일)

#### [요구사항 명세서 바로가기](https://www.notion.so/1-77e4fdb543504afd90accdc80f808117?pvs=4)

## 개발 환경
  <!-- 
  <img src="https://img.shields.io/badge/{내용}-{배경 색깔}?style={스타일}&logo={로고이름}&logoColor={로고 색깔}"/>
  <img src="https://img.shields.io/badge/-?logo= &logoColor=white">
  -->
### Front-End
<p>
    <img src="https://img.shields.io/badge/React-18.2.0-4f4f4f?style=flat&logo=react&logoColor=white&labelColor=136276">
    <img src="https://img.shields.io/badge/Node.js-18.17.1-4f4f4f?logo=nodedotjs&logoColor=white&labelColor=339933">
    <img src="https://img.shields.io/badge/HTML5-E34F26?style=flat&logo=HTML5&logoColor=white">
    <img src="https://img.shields.io/badge/CSS3-1572B6?style=flat&logo=css3&logoColor=white">
    <img src="https://img.shields.io/badge/Javascript-F7DF1E?style=flat&logo=javascript&logoColor=white">
</p>

### Back-End & Database
<p>
  <img src="https://img.shields.io/badge/Java-11-4f4f4f?logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAABn0lEQVR4nNXVPUiWURQH8LeisHwxqiUoowQx6AOhIVwKLYg+oCm3Phwa2oqChgiEEGwodHKoJcWh4SUICdHAQRqipYKghohEaEgcwoIi+MWtE7wEwXPreaEOHHgO99z//9z7P+c+lcq/aNjbSPCVuNco8HWYwEgjwPfhLWaxBidwC91lgJ/CV8ygiut4ho1lVf8eL7A64kWcLAU8GR6k66iLkw61SlmG9XiCTRFvxbvSCJKhBb3x3YEzlb8xnAtRU6dsx7Lf5K3ADjzEzRyCOyHmZ7zEY0yHT2EcA1gb+Z1Yyj3FUYzFlbSFJz22YM8vuZfTjOQSXMXH8NfhC37YPA5EXjceYVsWQWzeHTocDO/BERyq02BXNnAdwe2o+APm8CniJRz/E8DmqLQz4vR6HsNFXEoTHO/S96mOnFU5BOlJeIWuBF4gPxVwP4fgblzDEA6jHU11601oDS2u4Dn6Y61alCRtvhH9/ibm4Ut0U+qepxjF+Z+dg/0YzDnJ8gI5m3EWk1FQlhbpp7Izhq0PF3ANwzF8tZj209hQGPi/s28wfyzAH3ua7QAAAABJRU5ErkJggg==&logoColor=white&labelColor=4cc71e">
  <img src="https://img.shields.io/badge/Spring_Boot-2.6.6-4f4f4f?logo=springboot&logoColor=white&labelColor=6DB33F">
  <img src="https://img.shields.io/badge/Maven-C71A36?logo=apachemaven&logoColor=white">
</p>
<p>    
  <img src="https://img.shields.io/badge/MySQL-4479A1?logo=mysql&logoColor=white">
  <img src="https://img.shields.io/badge/Amazon_RDS-527FFF?logo=amazonrds&logoColor=white">
  <img src="https://img.shields.io/badge/Firebase-FFCA28?logo=firebase&logoColor=white">
</p>
  
### Deployment
<p>
  <img src="https://img.shields.io/badge/Docker-1b5e90?logo=docker&logoColor=white">
  <img src="https://img.shields.io/badge/Amazon_S3-446a29?logo=amazons3&logoColor=white">
  <img src="https://img.shields.io/badge/Amazon_EC2-ab6d10?logo=amazonec2&logoColor=white">
</p>

### Version Control
<p>
  <img src="https://img.shields.io/badge/Github-181717?logo=github&logoColor=white">
  <img src="https://img.shields.io/badge/Git-8b2813?logo=git&logoColor=white">
</p>

### Library
<p>
  <img src="https://img.shields.io/badge/Axios-391b89?logo=axios&logoColor=white">
  <img src="https://img.shields.io/badge/ReactQuery-FF4154?style=flat&logo=reactquery&logoColor=white">
  <img src="https://img.shields.io/badge/ReactRouter-CA4245?style=flat&logo=reactrouter&logoColor=white">
  <img src="https://img.shields.io/badge/Recoil-3578E5?style=flat&logo=recoil&logoColor=white">
  <img src="https://img.shields.io/badge/Emotion-cb0096?style=flat&logo=react&logoColor=white">
  <img src="https://img.shields.io/badge/StyledComponents-DB7093?style=flat&logo=styledcomponents&logoColor=white">
</p>
<p>
  <img src="https://img.shields.io/badge/Eslint-38297c?logo=eslint&logoColor=white">
  <img src="https://img.shields.io/badge/Prettier-8c6414?logo=prettier&logoColor=white">
  <img src="https://img.shields.io/badge/AntDesign-0170FE?style=flat&logo=antdesign&logoColor=white">
  <img src="https://img.shields.io/badge/D3.js-F9A03C?style=flat&logo=d3dotjs&logoColor=white">
  <img src="https://img.shields.io/badge/Day.js-f75c4a?style=flat&logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAW0lEQVR4nO2UQQqAMAwE93mt/39B85ARwR6rkGiVtnNeMmQJkb6CEz2U6yMANsDwY0C+EkSGV8rtulE0vkBOWIJxKqJxNUvQr6IWvxAYL7/rfAQiw4HkbUBzsgOtXAFqwVjmzwAAAABJRU5ErkJggg==&logoColor=white">
</p>
<p>
  <img src="https://img.shields.io/badge/JWT-000000?logo=jsonwebtokens&logoColor=white">
  <img src="https://img.shields.io/badge/MyBatis-271e1f.svg?logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAABuElEQVR4nO3US4hPcRQH8H9RI+Wx8FohkVfkUdQkC5FXxs6WhZSysSBCTWyRZpryWDHZi7LxSGRBKUtKMmGiRB6ZIvPRqbP4u917/zP/maXv6t77u+f7Ped8z/k1GiMANuI29mJuY7yBM/7F2bGQLcR2TMR8rMVsHMJd/MSftirBKgwrx03Mwv1839BuBdHnAfzCezzH1yR9gjv53IdH+IR3uIWudkXn4G0Sf8GQapxuV2QLvmENJqRXXTiGG0k+lAmsrCLpRTc2Y2rJ+YqKuGhVYFmrLPubSh1ODx7jepSOzoq4+E8mNg+TyxKMH1fnCNahP1pUiNuKF2n2ASzBDxwuE7moNQ5iJqZVVLQYr7G+7HA6XrYQuIxd+I2HOIUdafyUaA/WFSttFlmEjzUCx7G/5rynzuiOVI9snpYED2R77tUI7C4jjrKOYjAn6Fx+25bP13ACM3L2qxDxHc3Em3A1l6iID7iAPblo0ZYH6nGkmPl544dncQuXtWcfvo+RfBALWl1ol3L0RotXWF5JXhBamstW5kkRkcyV2J0RkReEJmFnehTGvsHnvLZjuU7GKI+a+D8aBfwFL0hrRFV1ciwAAAAASUVORK5CYII=&logoColor=white">
  <img src="https://img.shields.io/badge/Lombok-ca0124?logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEeElEQVR4nO2aW4hVVRjHP01HzZJGJcpuU6l00Uqzgl4sCrqgDz5IZZjZQxlEaKBJWVA9pEEG3QkqESrtAqWhY+WDQZBpF2ys1DLz0s3spqU2Nr/42GvR19eZaVpzBtaZs39wmLPP3vs/a+219ndbS6SkpKSkpKSk1gEOA14H/gBukXoDmMHfvCf1BHAU8L15AHOlngAeNJ3/Augv9QIwAjhoHsAkqSeAl03nV0tPAjgDuBt4E9gItAAXm/NnAW2h8/r3HOkJAKcElxY7Z1lmrnvE/L5cegLAJGAflTkE3GCu3WnOfQyMlFoGmBw6GWkFloTfTwcGmWsHVHhAvwDjpRYBTnMj/2lH7zQwtJ1Zshc4U2oNYIXr/OBOhL77jQHUjkc+AHpLrQCMcu/52Z2870Vz33bgN3N8tdQKwP2m4Uv/x30nAdvCfa8C9xidt6RWoAhfIxPduaOBdcAmf87kAZcBhwPHGNeps6FBcgcYZzr/M9DPnZ/mjNzzQFMHel+aa0+U3AEWmAYvrnB+mOtUdI865a8HRodZol5kivMkx0nOAL2Are1Nf3PdIOCpdiLD9mjNPisELu1o+le4/oIw8n924gF8KLkDrDQNfiMYLv3b9z/uawJuDpng2mBE1VD+aPRulBrw/W2hsTqi35nGj0rQ09kR+QkYKDkDLDINft98/wrok6C32GgslJyhmMK2imOt/KwEPfUCB8L9OqtGSM4AL5kOf+YM4ZEJevOMRrPkDDDeNLbNjf78BL2BwG6jMUFyhSKD+8g0dr35/quGsgmas41GS9ZZIIXrivwO7DHHdyToaVHkW6MxWXIFODWMcuRdl8oOSNCcaTQ+yXb0gb4hYLGuzkZz1yVo9gd2GY1rJFeA+1yMriMeWa05QRct/2a1L5Kx1T9kGvuOM3xNCZrDXAnsKskRYLhzUS0uo0uK14EXjMbbKTOo2wEGhypOZI8zgs2JU3+i0dCZNUZyA+gHrDEN3e8ehhrBoQm6jW4x5CHJDaCPFjZNI3XKL3P+f2xi8URrAZHPtQ4oOQE0AK/wT+4EnjPH0xK1b3NTP68VIAq/vNx1/olw7njgMWB6ovYVwX1G7pKcoEhIVrnOP1mNsrS+Ls7lNWcV8VGEuBtc51eFabqxK++prg26SpHqNUouUCxI2IRGmQ+8Zo7PTdQ+D/jB6HytK0GSAxQW+XYX4WmF56Zw/vyQ9i5KCVGBqcFbRL5JqRN256akNW7UdXQurIK2prePOu1tWZS4KPz7bDcyMbY/tgr6lwBbnLYWTE6oTg+6bujWuca1hve9oQrl8aUVVn2ezmJlh6Liandhxg0IY7ug2Vt3e4WFDb/Ko//rWskFim1qNqafm1i31/f7IuABYAf/Rh/EM8AQyQngWdPIe0NCYj9HmDC4MdT8dUPTlcCtwMMhZY11+0odX5KNlfcAc+ge1HMs1IclOQMMcSWsVNrCXj7d3Hh5tiWsSgAnh50ZO8MKrP3EjUkHwvHWELLq9tbHQxY3ISX/LykpKSkpKZHu5C8+ETRdu+5D6AAAAABJRU5ErkJggg==&logoColor=white">
</p>
</p>

### Tools
<p>
  <img src="https://img.shields.io/badge/VS_Code-007ACC?style=flat&logo=visualstudiocode&logoColor=white">
  <img src="https://img.shields.io/badge/IntelliJ-000000?logo=intellijidea&logoColor=white">
  <img src="https://img.shields.io/badge/GitKraken-179287?logo=gitkraken&logoColor=white">
  <img src="https://img.shields.io/badge/SourceTree-0057e5?logo=sourcetree&logoColor=white">
  <img src="https://img.shields.io/badge/Notion-000000?logo=notion&logoColor=white">
  <img src="https://img.shields.io/badge/Figma-f24e1e?logo=figma&logoColor=white">
</p>

## ERD 명세서
![ERD_Final](https://github.com/KoreaIt-J-23-2-5/Memorious-Front/assets/133538833/88d14372-8ef5-46f3-bd9b-aa6bc4439bb3)

## 기능 설명 및 코드리뷰

<!-- Example Foam !-->
### 회원가입 및 로그인
  <div>
    <img src="https://github.com/KoreaIt-J-23-2-5/Memorious-Front/assets/133538833/a1d7d556-e790-4439-954e-64ff997bcc59" width=60%>
  </div>
- 네이버, 카카오를 통한 회원가입을 지원합니다 ... 

  <details>
    <summary>Code Review</summary> 
    
    ```java
    public class BootSpringBootApplication {
      public static void main(String[] args) {
        System.out.println("Hello, Honeymon");
      }
    }
    ```
    
    {코드 설명...}
  </details>

<!-- 영상캡쳐 및 사진(gif)는 리팩토링 및 코드 수정 이후에 첨부 -->

### 가족 초대
- 가족의 이메일을 입력하여 가족을 초대할 수 있으며, 입력한 이메일로 초대 메일이 전송됩니다.
- 초대를 받은 회원은 가족이 입력한 이메일을 사용하여 회원가입을 완료하면 초대가 완료됩니다.
  <details>
    <summary>Code Review</summary> 
    - 회원가입 완료 후 요청을 보냄

    <details>
      <summary>service</summary> 
        
    ```java
    public boolean isInvitedByEmail () {
        PrincipalUser principalUser = (PrincipalUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        User user = principalUser.getUser();

        String email = user.getEmail(); //초대받는 사람의 email
        int userId = user.getUserId(); //초대 받는 사람의 userId
        int familyId = inviteMapper.getFamilyIdByEmail(email); //초대 하는 가족의Id

        // status : null(초대된 적 없음) 0(초대이력o, 가족소속x), 1(이미 소속완료)
        Integer inviteStatus = inviteMapper.getInvitationStatusByEmail(email);

        if(inviteStatus == null) {
            throw new MailException("초대된 적이 없습니다.");
        }

        if(inviteStatus == 1) {
            throw new MailException("이미 초대가 완료되었습니다.");
        }

        //member tb에 insert
        Map<String, Integer> memberMap = new HashMap<>();

        memberMap.put("userId", userId);
        memberMap.put("familyId", familyId);

        try {
            inviteMapper.insertMember(memberMap);
        } catch (Exception e) {
            e.printStackTrace();
        }
        //History의 초대상태 값을 1로 변경
        try {
            inviteMapper.updateHistory(email);
        }catch (Exception e) {
            e.printStackTrace();
            throw new MailException("초대 상태 수정 중 오류");
        }
        return inviteStatus == 0 ;
    }
    ```
    </details>

    <details>
      <summary>Mapper.xml</summary> 
        
    ```java
    <insert id="insertMember">
        insert into member_tb(member_id, user_id, family_id)
        values(0, #{userId}, #{familyId});
    </insert>

    <update id="updateHistory" parameterType="string">
        UPDATE invitation_history_tb
        SET status = 1
        WHERE invited_email = #{email}
    </update>

    <select id="getFamilyName" parameterType="map" resultType="String">
            SELECT
                ft.family_name
            FROM
                user_tb ut
                left outer join member_tb mt on(mt.user_id = ut.user_id)
                left outer join family_tb ft on(ft.family_id = mt.family_id)
            WHERE
                mt.user_id = #{userId}
                AND ft.family_id = #{familyId};
    </select>

    <select id="getInvitationStatusByEmail" parameterType="string" resultType="java.lang.Integer">
        SELECT
            status
        FROM
            invitation_history_tb
        WHERE
            invited_email = #{email};
    </select>

    <select id="getFamilyIdByEmail" parameterType="string" resultType="java.lang.Integer">
        SELECT
            ft.family_id
        FROM
            invitation_history_tb ht
            left outer join user_tb ut on(ut.user_id = ht.invite_user_id)
            left outer join member_tb mt on(mt.user_id = ut.user_id)
            left outer join family_tb ft on(ft.family_id = mt.family_id)
        WHERE
            invited_email = #{email};
    </select>
    ```
    </details>
    {코드 설명...}
  </details>

### 캘린더
<!-- 조회부 GIF -->
- 한 달 간의 가족 일정을 조회할 수 있으며 각각의 일정은 알고리즘이 정한 순서에 따라 보기좋게 배치됩니다.
  <details>
    <summary>Code Review</summary> 

    <details>
      <summary>1. 데이터 정렬</summary> 
      
    ```javascript
      const sortCalendarData = (a, b) => {
          // 1-1. 시작 날짜순 정렬
          const startDiff = dayjs(a.startDate).diff(b.startDate);
          if (startDiff !== 0) {
              return startDiff;
          }
        
        // 1-2. 일정 길이가 큰 순으로 정렬
        const diffA = dayjs(a.endDate).diff(a.startDate);
        const diffB = dayjs(b.endDate).diff(b.startDate);
    
        if (diffA > diffB) {
            return -1;
        }
        if (diffA < diffB) {
            return 1;
        }
    
        // 1-3. 종일 일정 우선
        if (a.isAllDay) {
            return -1;
        }
        if (b.isAllDay) {
            return 1;
        }
    
        // 1-4. 시작 시간이 이른 순서
        const startTimeA = dayjs(`${a.startDate} ${a.startTime}`);
        const startTimeB = dayjs(`${b.startDate} ${b.startTime}`);
    
        return startTimeA.diff(startTimeB);
      };
    
    ```
    </details>
  
    <details>
      <summary>2. 데이터 전처리</summary> 
      
    ```javascript
      // 여러 주에 걸친 일정들을 주 단위로 나누고 일정 표시에 필요한 인덱스값 추가
      const preprocessData = schedule => {
          let startDate = dayjs(schedule.startDate);
          const endDate = dayjs(schedule.endDate);
          const weeklySchedules = [];
          let weekIndex = 1;
  
      // 여러 일의 일정들만 수행
      if (schedule.startDate !== schedule.endDate) {
          // 주를 나누기 위해 시작날짜부터 종료날짜까지 반복
          while (startDate.isBefore(endDate) || startDate.isSame(endDate)) {
              // 시작 날이 있는 주의 첫날과 끝날
              const { startOfWeek, endOfWeek } = getWeekRange(startDate);
  
              // 주의 시작일이 해당 일정의 시작일 이전이면 시작일을 해당 일정의 시작일로 설정
              const adjustedStartOfWeek = startDate.isAfter(startOfWeek) ? startDate : startOfWeek;
              // 주의 종료일이 해당 일정의 종료일 이후이면 종료일을 해당 일정의 종료일로 설정
              const adjustedEndOfWeek = endDate.isBefore(endOfWeek) ? endDate : endOfWeek;
  
              // 며칠짜리 일정인지 인덱스 부여하고 배열에 추가함
              const dayDiff = adjustedEndOfWeek.diff(adjustedStartOfWeek, "day") + 1;
              weeklySchedules.push({
                  ...schedule,
                  startDate: adjustedStartOfWeek.format("YYYY-MM-DD"),
                  endDate: adjustedEndOfWeek.format("YYYY-MM-DD"),
                  dayDiff,
                  weekIndex,
              });
  
              // startDate를 다음주의 첫 날로 변경
              startDate = startOfWeek.add(1, "week");
              weekIndex += 1;
          }
      } else {
          // 당일 일정들 배열에 추가
          weeklySchedules.push({ ...schedule, dayDiff: 0, weekIndex: 0 });
      }
      return weeklySchedules;
      };
    ```
    </details>
    
    <details>
      <summary>3. 데이터 분류 및 순서인덱스 부여 </summary> 
      
    ```javascript
        const getfilteredData = () => {
            const dateArray = getVisibleDates(currentDate); // 화면에 보여지는 42개의 날짜를 배열로 만듬
            const returnData = dateArray.map(() => []); // 비어있는 배열

            // 알고리즘에 의해 정렬된 일정먼저 순서를 부여함
            scheduleData.forEach(schedule => {
                let uqKey = 1;
                // 캘린더에 보여지는 날짜 수(42)만큼 반복하며
                for (let i = 0; i < dateArray.length; i++) {
                    const scheduleStart = dayjs(schedule.startDate);
                    const scheduleEnd = dayjs(schedule.endDate);
                    let index = 1;
                    let isBetween = false;
  
                    // 배열 맨 처음 인덱스에는 해당 날짜를 설정
                    if (returnData[i].length === 0) {
                        returnData[i].push({ date: dateArray[i].format("YYYY-MM-DD") });
                    }

                    if (i > 0) {
                        // 같은 날짜에 있는 배열을 찾아보며 비어있는 자리를 찾는다.
                        for (let j = 0; j < returnData[i].length; j++) {
                            if (returnData[i].every(value => value.index !== j + 1)) {
                                // value.index가 i + 1이 아닌 경우 (비어 있는 경우)
                                index = j + 1;
                                break;
                            }
                        }
                        // 전 날 배열을 참조해 자신과 같은 일정이라면 같은 인덱스로 설정
                        returnData[i - 1].forEach(value => {
                            if (value?.scheduleId === schedule.scheduleId && value?.weekIndex === schedule.weekIndex) {
                                index = value?.index;
                            }
                        });
                    }
    
                    // 결과 배열에 넣으며 순서인덱스 부여 및 보임여부 인덱스 부여(*모든 일정은 시작 날짜의 일정만 표시한다.) 
                    if (schedule.dayDiff !== 0 && schedule.startDate === dateArray[i].format("YYYY-MM-DD")) {
                        returnData[i].push({ ...schedule, index, isBetween, uqKey });
                        // 2: 시작날짜를 초과, 종료날짜 이전 일정의 경우 보이지 않도록 함(*오직 순서 인덱스를 참고하기 위해 사용됨)
                    } else if (schedule.dayDiff !== 0 && dateArray[i].isAfter(scheduleStart) && (dateArray[i].isBefore(scheduleEnd) || dateArray[i].isSame(scheduleEnd, "day"))) {
                        isBetween = true;
                        if (dateArray[i].isSame(scheduleEnd, "day")) {
                            returnData[i].push({ ...schedule, index, isBetween, uqKey });
                        } else {
                            returnData[i].push({ ...schedule, index, isBetween, uqKey });
                        }
                        // 3: 하루짜리 일정을 결과 배열에 넣음
                    } else if (schedule.dayDiff === 0 && schedule.startDate === dateArray[i].format("YYYY-MM-DD")) {
                        returnData[i].push({ ...schedule, index, isBetween, uqKey });
                    }
                    uqKey += 1;
                }
            });
            setFilteredData(returnData);
        };
    ```
    </details>

    <details>
      <summary>4. 일정 표시 </summary> 
      
    ```javascript
        const cellRender = date => {
              const formattedDate = date.format("YYYY-MM-DD");
              // 셀의 날짜와 같은 날짜인 결과값 배열만 찾아담음
              const matchingDateArray = filteredData?.find(entry => entry[0] && entry[0].date === formattedDate);
              if (matchingDateArray && Array.isArray(matchingDateArray)) {
                  const maxIndex = matchingDateArray.length - 1;
      
                  return (
                      <div css={SdateCellBox(customHeight)} onClick={e => handleContainerClick(e, date, matchingDateArray)}>
                          <ul className="schedules">{matchingDateArray.map(schedule => renderSchedules(schedule, maxIndex))}</ul>
                      </div>
              );
        }
    
       const renderSchedules = (schedule, maxIndex) => {
            //유효하지 않은 값은 버림
            if (schedule?.date) {
                return null;
            }
            //사이에 낀 일정은 표시되지 않음
            if (schedule?.isBetween) {
                return (
                    <div css={SEmptyBox(schedule?.index, visibleSchedulesNum)} key={`${schedule?.scheduleId}-${schedule?.weekIndex}-${schedule?.uqKey}-1`}>
                        {schedule?.title}
                    </div>
                );
            }
            // 최대 가시 일정 개수보다 적으면 일반적인 표시
            if (schedule?.index <= visibleSchedulesNum) {
                return (
                    <>
                        <div css={SScheduleBox(schedule?.dayDiff, schedule?.isAllDay, schedule?.labelColor, schedule?.index, visibleSchedulesNum)} key={`${schedule?.scheduleId}-${schedule?.weekIndex}-${schedule?.uqKey}-2`}>
                            {schedule?.isAllDay ? null : (
                                <>
                                    {schedule?.dayDiff === 0 && <Badge color={schedule?.labelColor} />}
                                    <span css={STimeText}>{convertTo24HourFormat(schedule?.startTime)}</span>
                                </>
                            )}
                            <li className={schedule?.scheduleId} css={SScheduleText(schedule?.labelColor, schedule?.isAllDay, schedule?.dayDiff)} key={`${schedule?.scheduleId}-${schedule?.weekIndex}-${schedule?.uqKey}-3`}>
                                {schedule?.title}
                            </li>
                        </div>
                    </>
                );
            }
            // 최대 가시 일정 개수보다 많을 때 '...N개 더보기'
            if (schedule?.index === visibleSchedulesNum + 1) {
                return (
                    <>
                        <div css={SMoreText(schedule?.index)} key={`${schedule?.scheduleId}-${schedule?.weekIndex}-${schedule?.uqKey}-4`}>
                            <p key={`${schedule?.scheduleId}-${schedule?.weekIndex}-${schedule?.uqKey}-5`}>{maxIndex - visibleSchedulesNum}개 더보기</p>
                        </div>
                    </>
                );
            }
        };
    
    ```
    </details>
    
- '오늘' '다음 월' '이전 월' 버튼과 연도 드롭다운을 통해 편리하게 원하는 월로 이동할 수 있습니다.
-  해상도가 16:9 환경에서는 5행(6주인 월에는 6행), 16:10 환경에서는 6행의 캘린더를 보여주고, 셀의 height값에 맞게 일정이 표시됩니다.
      <details>
        <summary>Code Review</summary> 
        
      ```javascript
      // 화면 비율에따라 5행 / 6행 다르게 표시
      const useDynamicHeight = date => {
          const defaultHeight = 133; //FHD 크롬 기준
          const [customHeight, setCustomHeight] = useState(defaultHeight);
          const [rowNumber, setRowNumber] = useState(5);
      
          const updateDynamicHeight = () => {
              const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
              const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
              let calculatedHeight;
              const viewportRatio = viewportWidth / viewportHeight;
      
              if (viewportRatio <= 1.9) {
                  calculatedHeight = (viewportHeight - 265) / 6;
                  setRowNumber(6);
              } else {
                  calculatedHeight = (viewportHeight - 240) / 5;
                  setRowNumber(5);
              }
              // 만약 해당 월이 6주짜리 월이라면 반드시 6행으로 표시(ex. 1일:토요일, 31일:화요일)
              if (getWeekCount(date) === 6) {
                  calculatedHeight = (viewportHeight - 268) / 6;
                  setRowNumber(6);
              }
              setCustomHeight(calculatedHeight);
          };
    
          //화면 크기 조정시 작동
          useEffect(() => {
              window.addEventListener("resize", updateDynamicHeight);
              updateDynamicHeight();
      
              return () => {
                  window.removeEventListener("resize", updateDynamicHeight);
              };
          }, []);
    
          //날짜 변경시 작동
          useEffect(() => {
              updateDynamicHeight();
          }, [date]);
    
          return { customHeight, rowNumber };
      };
      ```
      </details>
-  한 날짜에 모든 일정을 보여주지 못할 경우 'n개 더보기'를 표시하고, 해당 날짜의 전체 일정을 확인할 수 있는 모달창을 띄어줍니다.
<!-- 추가 GIF -->
- '일정 추가' 버튼 또는 일정 셀을 클릭해 클릭한 날짜에 일정을 추가할 수 있습니다.
- 반복 주기(5가지)와 종료일 또는 종료 횟수를 직접 정하여 반복되는 일정을 추가할 수 있습니다.
   <details>
        <summary>Code Review</summary> 

    <details>
      <summary>1. service</summary> 
        
    ```java
    @Transactional(rollbackFor = Exception.class)
    public boolean addSchedule(ScheduleReqDto scheduleReqDto) {
        ScheduleEntity scheduleEntity = scheduleReqDto.toEntity();

        String repeatType = scheduleReqDto.getRepeatCycle();
        String repeatEndType = scheduleReqDto.getRepeatType();
        int repeatCount = scheduleReqDto.getRepeatCount();
        int repeatLimitYear = 5;
        switch (repeatType) {
            case "":
                return calendarRepeatUtil.addSchedule(scheduleReqDto);
            // 매월 반복인경우
            case "month":
                switch (repeatEndType) {
                    case "none":
                        repeatCount = 12 * repeatLimitYear;
                        return calendarRepeatUtil.monthRepeatCount(scheduleReqDto, repeatCount);
                    case "count":
                        repeatCount = scheduleReqDto.getRepeatCount();
                        return calendarRepeatUtil.monthRepeatCount(scheduleReqDto, repeatCount);
                    case "date":
                        String repeatEndDate = scheduleReqDto.getRepeatEndDate();
                        LocalDate repeatEndDateObj = LocalDate.parse(repeatEndDate, DateTimeFormatter.ISO_LOCAL_DATE);
                        return calendarRepeatUtil.monthRepeatDate(scheduleReqDto);
                    default: return false;
                }
            // 매년 반복인 경우 
            case "year":
                switch (repeatEndType) {
                    case "none":
                        repeatCount = repeatLimitYear;
                        return calendarRepeatUtil.yearRepeatCount(scheduleReqDto, repeatCount);
                    case "count":
                        return calendarRepeatUtil.yearRepeatCount(scheduleReqDto, repeatCount);
                    case "date":
                        return calendarRepeatUtil.yearRepeatDate(scheduleReqDto);
                    default: return false;

                }
                // 반복주기가 숫자인 경우(매일/매주/n일)
                default:
                    switch (repeatType) {
                        case "day":
                            repeatType = "1";
                            break;
                        case "week":
                            repeatType = "7";
                            break;
                        default:
                            break;
                    }
                    int repeatCycle = Integer.parseInt(repeatType);

                    switch (repeatEndType) {
                        case "none":
                            String startDate = scheduleReqDto.getStartDate();
                            LocalDate startDateObj = LocalDate.parse(startDate, DateTimeFormatter.ISO_LOCAL_DATE);
                            LocalDate lastDate = startDateObj.plusYears(repeatLimitYear);
                            return calendarRepeatUtil.dayRepeatDate(scheduleReqDto, lastDate, repeatCycle);

                        case "date":
                            String repeatEndDate = scheduleReqDto.getRepeatEndDate();
                            LocalDate repeatEndDateObj = LocalDate.parse(repeatEndDate, DateTimeFormatter.ISO_LOCAL_DATE);
                            return calendarRepeatUtil.dayRepeatDate(scheduleReqDto, repeatEndDateObj, repeatCycle);

                        case "count":
                            return calendarRepeatUtil.dayRepeatCount(scheduleReqDto, repeatCount, repeatCycle);
                        default: return false;
                    }
                }
            }
      }
    ```
    
    </details>
        <details>
      <summary>2. CalendarRepeatUtil</summary> 
        
    ```java
    public class CalendarRepeatUtil {
    
        private final CalendarMapper calendarMapper;
          //참석자가 있는 경우
        private boolean processScheduleWithAttendees(ScheduleEntity scheduleEntity, ScheduleReqDto scheduleReqDto) {
            calendarMapper.insertSchedule(scheduleEntity);
            Map<String, Object> map = new HashMap<>();
            map.put("calendarScheduleId", scheduleEntity.getCalendarScheduleId());
            map.put("userIdList", scheduleReqDto.getAttendee());
            return calendarMapper.insertAttendee(map) > 0;
        }
    
        // 메서드에서 사용할 조건을 분리하고 메서드 호출로 대체
        public boolean addSchedule(ScheduleReqDto scheduleReqDto) {
            ScheduleEntity scheduleEntity = scheduleReqDto.toEntity();
            // 참석자 여부에 따라 처리
            if (hasAttendees(scheduleReqDto)) {
                return processScheduleWithAttendees(scheduleEntity, scheduleReqDto);
            } else {
                return calendarMapper.insertSchedule(scheduleEntity) > 0;
            }
        }
    
        // 참석자가 있는지 여부를 확인
        private boolean hasAttendees(ScheduleReqDto scheduleReqDto) {
            return scheduleReqDto.getAttendee() != null && scheduleReqDto.getAttendee().toArray().length > 0;
        }
    
        // 월 + 특정횟수 반복
        public boolean monthRepeatCount(ScheduleReqDto scheduleReqDto, int repeatCount) {
            String startDate = scheduleReqDto.getStartDate();
            LocalDate startDateObj = LocalDate.parse(startDate, DateTimeFormatter.ISO_LOCAL_DATE);
            String endDate = scheduleReqDto.getEndDate();
            LocalDate endDateObj = LocalDate.parse(endDate, DateTimeFormatter.ISO_LOCAL_DATE);
    
            for(int i=0; i < repeatCount; i++ ) {
                LocalDate addYearStartDate = startDateObj.plusMonths(i);
                scheduleReqDto.setStartDate(addYearStartDate.toString());
                LocalDate addYearEndDate = endDateObj.plusMonths(i);
                scheduleReqDto.setEndDate(addYearEndDate.toString());
                addSchedule(scheduleReqDto);
            }
            return true;
        }
        // 월 + 종료일까지 반복
        public boolean monthRepeatDate(ScheduleReqDto scheduleReqDto) {
            String startDate = scheduleReqDto.getStartDate();
            LocalDate startDateObj = LocalDate.parse(startDate, DateTimeFormatter.ISO_LOCAL_DATE);
            String endDate = scheduleReqDto.getEndDate();
            LocalDate endDateObj = LocalDate.parse(endDate, DateTimeFormatter.ISO_LOCAL_DATE);
            String repeatEndDate = scheduleReqDto.getRepeatEndDate();
            LocalDate repeatEndDateObj = LocalDate.parse(repeatEndDate, DateTimeFormatter.ISO_LOCAL_DATE);
    
            int i = 0;
            do {
                startDateObj = startDateObj.plusMonths(i);
                scheduleReqDto.setStartDate(startDateObj.toString());
                endDateObj = endDateObj.plusMonths(i);
                scheduleReqDto.setEndDate(endDateObj.toString());
                addSchedule(scheduleReqDto);
                i++;
            } while (startDateObj.isBefore(repeatEndDateObj));
            return true;
        }
          ...나머지 method생략
    ```
    </details>

    <details>
      <summary>3. Mapper.xml</summary> 
        
    ```java
    <resultMap id="CalendarSchedule" type="com.memorious.back.entity.CalendarScheduleEntity">
        <id property="scheduleId" column="calendar_schedule_id" />
        <result property="userId" column="user_id"/>
        <result property="title" column="title"/>
        <result property="labelColor" column="label_color"/>
        <result property="startDate" column="start_date"/>
        <result property="endDate" column="end_date"/>
        <result property="isAllDay" column="is_all_day"/>
        <result property="startTime" column="start_time"/>
        <result property="endTime" column="end_time"/>
        <result property="location" column="location"/>
        <result property="repeatType" column="repeat_type"/>
        <result property="repeatCycle" column="repeat_cycle"/>
        <result property="repeatEndDate" column="repeat_end_date"/>
        <result property="repeatCount" column="repeat_count"/>
        <result property="description" column="description"/>
        <result property="nickname" column="nickname"/>
        <collection property="attendees" javaType="list" resultMap="CalendarAttendeeResultMap" />
    </resultMap>

    <resultMap id="CalendarAttendeeResultMap" type="com.memorious.back.entity.CalendarAttendeeEntity">
        <id property="attendeeId" column="attendee_user_id"/>
        <result property="attendeeNickName" column="attendee_nickname"/>
    </resultMap>

    <insert id="insertSchedule"
            useGeneratedKeys="true"
            keyProperty="calendarScheduleId"
            parameterType="com.memorious.back.entity.ScheduleEntity">
        INSERT INTO calendar_schedule_tb (
            calendar_schedule_id,
            user_id,
            title,
            label_color,
            start_date,
            end_date,
            is_all_day,
            start_time,
            end_time,
            location,
            repeat_type,
            repeat_cycle,
            repeat_end_date,
            repeat_count,
            description
        )
        VALUES (
            0,
            #{userId},
            #{title},
            #{labelColor},
            #{startDate},
            #{endDate},
            #{isAllDay},
            #{startTime},
            #{endTime},
            #{location},
            #{repeatType},
            #{repeatCycle},
            #{repeatEndDate},
            #{repeatCount},
            #{description}
        )
    </insert>

    <insert id="insertAttendee" parameterType="hashmap">
        insert into calendar_attendee_tb
        values
        <foreach collection="userIdList" item="userId" separator=",">
            (0, #{calendarScheduleId}, #{userId})
        </foreach>
    </insert>
    ```
    </details>
    
  ```java

        
  ```
  </details>
<!-- 상세조회 / 수정 / 삭제 GIF -->
- 등록된 일정을 클릭하면 세부 내용을 확인하고, 수정 또는 삭제할 수 있습니다.
  
  <details>
    <summary>Code Review</summary> 
    
    ```javascript
      const fetchData = async () => {
      };
    ```
    
    {코드 설명...}
  </details>

### 메모
- 포스트잇과 비슷한 형태의 메모를 작성할 수 있습니다.
- 최신 일정순으로 정렬되며 무한스크롤을 지원합니다.
- 작성자 본인만이 메모를 수정하거나 삭제 할 수 있습니다.
- 내용에 포함된 키워드로 검색할 수 있으며 새로고침 버튼을 통해 새로운 메모를 조회할 수 있습니다.


### 게시판
- 설명

  <details>
    <summary>Code Review</summary> 
    
    ```javascript
      const fetchData = async () => {
      };
    ```
    
    {코드 설명...}
  </details>

### 건강 차트
- 혈당, 걸음수, 맥박 데이터를 그래프로 직관적으로 표시합니다.
- 사이드바에서 인원별, 기간별(1, 3, 6개월) 필터링을 지원합니다.
- 입력페이지에서 데이터를 손쉽게 추가 및 수정(모달)할 수 있습니다.


### 그 외
- 사이드바 하단에서 프로필 사진을 클릭해 변경할 수 있습니다.


## 느낀 점
### 주성광
- (협업에 대하여) 팀 프로젝트는 개인 프로젝트와 많은 부분에서 다르다는 것을 크게 느꼈다. 우리 조는 효율성을 중시해 메인 기능을 기준으로 철저한 분업을 꾀했는데, 철저한 분업은 맡은 기능에 대한 전문성을 강화하고 책임감과 의욕을 고취하는 데 큰 장점이 있는 반면 팀원 간 소통의 필요성을 잊게했다. 소통의 부족은 코드 리뷰를 하거나 피드백을 주고받는 지식 공유의 시간을 감소시켰고 이는 협업에서의 가장 큰 장점인 집단지성을 활용하지 못하는 결과를 낳았다.

   주기적인 미팅과 코드 리뷰와 같은 협업 시스템 내지 협업 규칙의 중요성, 그리고 비록 사소해 보이는 루틴일지라도 개개인이 이러한 체계를 지키려는 노력이 정말 중요하다는 것을 깨닫게 되었다. 또한 역할분담 내지 개발론과 같은 협업 방식을 채택할 때에는 프로젝트의 목적 및 규모, 팀원의 역량 및 경험 등을 종합적으로 고려해야 하고, 채택 후에는 채택한 방식의 리스크를 최소화 할 수 있는 시스템을 반드시 마련해야 함을 느꼈다. 

- (개발 전반) 하나의 프로젝트를 기획부터 개발까지 직접 경험함으로써 기획자, 디자이너, 그리고 프론트엔드와 백엔드 각각의 역할과 그 중요성을 경험했다. 프론트 단과 백엔드 단 어디에서나 처리할 수 있는 문제이더라도 어디서 처리하는것이 적절한지를 고민하는 과정을 통해 각 파트의 역할을 다시 한번 생각해 볼 수 있었다. 또한 프론트에서는 사용자 중심의 웹을 기획하고 구현하는 것을, 백에서는 성능과 클린코드를 어떻게 함께 잡을지에 대해 고민하며 개발의 다양한 측면과 개발 흐름을 명확히 이해할 수 있었다.

  이러한 경험을 통해 주니어 개발자로서의 향후 학습 방향을 잡을 수 있었다. 한편, 백엔드 과정의 최종 프로젝트라는 성격을 고려할 때, 사용자 중심적인 웹을 구현하겠다는 욕심에 퍼블리싱과 프론트엔드 부분에 많은 시간을 써 추가 기능으로 생각했던 알림 기능, 공공데이터 공휴일 API 기능, 커뮤니티 기능 등을 통해 백엔드를 충분히 연습하지 못해 아쉽다. jwt, oAuth, 기타 CRUD, 알림 기능 등 연습하지 못한 부분은 별도의 프로젝트로 보충해야할 필요성을 느낀다. 

- (FE) 이제껏 수업에서는 배우지 않았던 여러 라이브러리(Eslint, AntD, DayJS, StyledComponents)를 도입했다. 요구사항에 맞게 새로운 기술을 응용해 사용하기가 쉽지는 않았지만, 새로운 기술을 습득하는 과정이 흥미로웠고 완성도 높은 라이브러리를 사용함으로서 프로젝트의 퀄리티도 높아짐에 따라 성취감을 느낄 수 있었다.

  한편, 캘린더 기능은 보기와 달리 더더욱 쉽지 않았다. 특히 일정을 여타 캘린더 앱처럼 일정한 순서와 규칙에 맞게 표시하는 것은 불가능한 문제로 느껴졌다. 마음을 다잡고 직면한 문제와 요구사항에 대해 차분히 고민하며 해결 로직을 단계별로 정리했고, 이에 필요한 함수와 기능을 학습한 후 정리한 로직을 코드로 옮겨내는 데 성공했다. 이런 경험을 통해 포기하지 않으면 어떤 문제라도 반드시 해결할 수 있다는 믿음과 자신감을 얻게 되었다.

- (BE) 캘린더의 일정 반복 추가 기능을 구현하는 것이 가장 복잡한 작업이었다. 16가지 경우의수를 처리해야 했는데, 각각의 경우의수를 따져보며 9가지 경우를 정의하고 6가지의 메서드를 실행하는 방식으로 구현했다. 서비스단 코드의 가독성과 CSR을 고려해 클래스를 분리하고 코드의 재사용성을 높이는 등 많은 노력을 한 결과이지만 중첩 switch 문을 사용했기에 가독성이 떨어지는 아쉬움이 있다. 또한 '매일' 반복일 경우 한 번에 3,650 개의 데이터가 DB에 추가되며 성능 문제가 발생했다. OOP에 대한 이해와 개발 언어 및 SQL의 기본기, 클린코드, 알고리즘과 자료구조 등 CS 공부가 필수적임을 깨닫게 되었다. 기획단계에서 철저히 DB 설계를 한 덕분에 개발단계에서 DB 관련한 애로사항이나 변경사항이 없었던 점은 다행이였다. 
  
### 우주영

